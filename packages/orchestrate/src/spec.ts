import { randomUUID } from 'node:crypto'
import type { OpenCodeAdapter } from './opencode-adapter.js'
import type { OrchestrationPackage, OrchestratorOutput, RunRecord } from './types.js'

export type SpecGenerateRequest = {
  prompt: string
  model?: string
  mode?: 'simple' | 'advanced'
}

export type SpecDocument = {
  path: string
  title: string
  content: string
}

export type SpecGenerateResponse = {
  specId: string
  createdAt: string
  documents: SpecDocument[]
  orchestrationPackage: OrchestrationPackage
  orchestrator: {
    plan: OrchestratorOutput
  }
}

export async function generateSpecBundle(input: {
  adapter: OpenCodeAdapter
  prompt: string
  model: string
}): Promise<SpecGenerateResponse> {
  const createdAt = new Date().toISOString()
  const specId = `spec_${randomUUID()}`

  const orchestrationPackage: OrchestrationPackage = {
    packageVersion: '0.1.0',
    metadata: {
      packageId: specId,
      createdAt,
      createdBy: 'openchamber:auto',
      source: 'openchamber:auto',
      tags: ['auto-mode', 'spec'],
    },
    objective: {
      title: inferTitleFromPrompt(input.prompt),
      description: input.prompt.trim(),
      inputs: {},
      doneCriteria: [
        {
          id: 'done_1',
          description: 'Feature works end-to-end and matches the spec',
          requiredEvidenceTypes: ['diff', 'test_result', 'log_excerpt'],
        },
      ],
    },
    agents: {
      orchestrator: {
        name: 'orchestrator',
        model: input.model,
        systemPromptRef: 'openchamber/orchestrator-system',
      },
      worker: {
        name: 'worker',
        model: input.model,
        systemPromptRef: 'openchamber/worker-system',
      },
    },
    registries: {
      skills: [],
      variables: [],
    },
    runPolicy: {
      limits: {
        maxOrchestratorIterations: 4,
        maxWorkerIterations: 6,
        maxRunWallClockMs: 20 * 60 * 1000,
      },
      retries: {
        maxWorkerTaskRetries: 1,
        maxMalformedOutputRetries: 1,
      },
      concurrency: {
        maxWorkers: 4,
      },
      timeouts: {
        workerTaskMs: 2 * 60 * 1000,
        orchestratorStepMs: 2 * 60 * 1000,
      },
      budget: {
        maxTokens: 250_000,
        maxCostUsd: 25,
      },
      determinism: {
        enforceStageOrder: true,
        requireStrictJson: true,
        singleSessionPerRun: true,
      },
    },
  }

  const fakeRun: RunRecord = {
    id: specId,
    status: 'queued',
    reason: null,
    cancelRequested: false,
    orchestrationPackage,
    createdAt,
    updatedAt: createdAt,
    startedAt: null,
    finishedAt: null,
    sessionId: null,
    budgetTokensUsed: 0,
    budgetCostUsed: 0,
  }

  const plan = await input.adapter.runOrchestratorStage({
    run: fakeRun,
    stage: 'plan',
    iteration: 1,
    workerResults: [],
  })

  const documents: SpecDocument[] = [
    {
      path: 'SPEC.md',
      title: 'Spec',
      content: renderSpecMarkdown({ prompt: input.prompt, pkg: orchestrationPackage, plan }),
    },
    {
      path: 'TASKS.md',
      title: 'Tasks',
      content: renderTasksMarkdown(plan),
    },
    {
      path: 'ORCHESTRATION_PACKAGE.json',
      title: 'OrchestrationPackage',
      content: JSON.stringify(orchestrationPackage, null, 2),
    },
  ]

  return {
    specId,
    createdAt,
    documents,
    orchestrationPackage,
    orchestrator: { plan },
  }
}

function inferTitleFromPrompt(prompt: string): string {
  const first = prompt.split('\n').map((l) => l.trim()).filter(Boolean)[0] ?? ''
  if (!first) return 'Objective'
  return first.length > 120 ? `${first.slice(0, 117)}...` : first
}

function renderSpecMarkdown(input: { prompt: string; pkg: OrchestrationPackage; plan: OrchestratorOutput }): string {
  const objective = input.pkg.objective
  const goals = input.plan.plan?.goals ?? []
  const tasks = input.plan.plan?.tasks ?? []
  const criteria = objective.doneCriteria ?? []

  return [
    `# ${objective.title}`,
    '',
    objective.description.trim() || '_No description provided._',
    '',
    '## Goals',
    ...(goals.length > 0 ? goals.map((g) => `- ${g}`) : ['- _Not specified_']),
    '',
    '## Done Criteria',
    ...(criteria.length > 0
      ? criteria.map((c) => `- ${c.description}`)
      : ['- _Not specified_']),
    '',
    '## Task Graph (Draft)',
    ...(tasks.length > 0
      ? tasks.map((t) => `- ${t.taskId}: ${t.objective}`)
      : ['- _No tasks produced_']),
    '',
    '## Notes',
    '- This spec bundle was generated by the Orchestrate orchestrator stage (plan).',
  ].join('\n')
}

function renderTasksMarkdown(plan: OrchestratorOutput): string {
  const tasks = plan.plan?.tasks ?? []
  if (tasks.length === 0) {
    return '# Tasks\n\n_No tasks produced._\n'
  }
  return [
    '# Tasks',
    '',
    ...tasks.flatMap((t) => [
      `## ${t.taskId}`,
      '',
      `Objective: ${t.objective}`,
      '',
      `Priority: ${t.priority}`,
      '',
      `Required evidence: ${(t.requiredEvidence ?? []).join(', ') || 'none'}`,
      '',
      `Dependencies: ${(t.dependencies ?? []).join(', ') || 'none'}`,
      '',
    ]),
  ].join('\n')
}
